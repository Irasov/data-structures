# JavaScript: структуры данных и алгоритмы. Часть 4

## 12. Дерево отрезков

Описание

[Википедия](https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_%D0%BE%D1%82%D1%80%D0%B5%D0%B7%D0%BA%D0%BE%D0%B2)

[YouTube](https://www.youtube.com/watch?v=LEkEPE_BKQY)

Дерево отрезков (сегментов) (segment tree), также известное как статистическое дерево (statistic tree) — это структура данных, которая используется для хранения информации об отрезках (сегментах, диапазонах). Эта структура данных позволяет запрашивать, какой сегмент содержит определенное значение. По сути, дерево отрезков является статичной структурой данных — ее структура не может меняться после создания.

Дерево отрезков — это двоичное дерево (binary tree, см. часть 3, раздел 9). Корень дерева представляет весь массив. Потомки дерева представляют левую и правую половины массива. Аналогично, потомки каждого узла представляют половины массива, соответствующего узлу.

Дерево строится снизу вверх. Значение предка — это значение минимального потомка (или другое значение в зависимости от переданной функции). Построение дерева занимает время O(n log n). Количество операций — это высота дерева и равняется O(n log n). Для выполнения запросов диапазона (range queries) каждый узел разбивает запрос на две части, по одному подзапросу для каждого потомка. Если запрос содержит весь подмассив узла, мы можем вернуть предварительно вычисленное значение узла. Эта оптимизация позволяет добиться O(n log n) операций.

![Дерево отрезков](https://habrastorage.org/r/w1560/webt/gi/i6/uy/gii6uyehmtmmktqk9hlkz8zj0_w.png)

![Дерево отрезков](https://habrastorage.org/r/w1560/webt/kw/ah/sd/kwahsdixbt1ir6lu1uvpgaph3ak.png)

Случаи применения

Дерево отрезков — это структура данных, спроектированная для эффективного выполнения некоторых операций с массивами, особенно, операций, включающих запросы диапазона.

Такие деревья часто применяются в вычислительной геометрии и географических информационных системах.

Наша реализация дерева отрезков будет принимать любую функцию (принимающую два параметра), позволяя выполнять разные запросы диапазона.

Интерактивную визуализацию дерева отрезков можно посмотреть [здесь.](https://visualgo.net/en/segmenttree)

### Сложность

Временная

| Поиск     | Запрос диапазона |
| --------- | ---------------- |
| O(log(n)) | O(log(n))        |

Пространственная

O(n)

## 13. Дерево Фенвика

[Википедия](https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_%D0%A4%D0%B5%D0%BD%D0%B2%D0%B8%D0%BA%D0%B0)

[YouTube](https://www.youtube.com/watch?v=muW1tOyqUZ4)

Дерево Фенвика (Fenwick tree) или двоичное индексированное дерево (ДИД, binary indexed tree, BIT) — это структура данных, которая позволяет эффективно обновлять элементы и вычислять их суммы.

По сравнению с обычным массивом, ДИД позволяет достичь лучшего баланса между двумя операциями: обновлением элементов и вычислением суммы элементов. В массиве n чисел можно хранить либо сами числа, либо их суммы. В первом случае вычисление суммы чисел занимает линейное время. Во втором случае обновление элемента занимает линейное время. Противоположные операции выполняются за константное время. ДИД позволяет выполнять обе операции за время O(log n). Это достигается за счет представления чисел в виде дерева, где значением каждого узла является сумма чисел поддерева. Структура дерева позволяет выполнять операции за O(log n) доступов к узлам.

### Особенности реализации

ДИД представлено в виде массива. Каждый узел дерева хранит сумму узлов некоторого поддерева. Размер ДИД равен n, где n — размер исходного массива. В нашей реализации будет использоваться размер n+1 для простоты. Индексация начинается с 1.

![Дерево Фенвика](https://habrastorage.org/r/w1560/webt/v-/ox/oz/v-oxozce98rjgk36iyylbb3kgiu.png)

Пример получения суммы элементов с помощью ДИД

- каждый узел имеет индекс (синий) и значение по индексу (зеленый)
- при запросе суммы i, возвращается сумма BITree[i] и всех предков i
- индекс предка i может быть получен с помощью следующей формулы: parent(i) = i - i & (-i). Данная операция удаляет последний установленный бит i. Например, если i=12, то parent(i) вернет 8

Анимированный пример создания ДИД для массива [1, 2, 3, 4, 5] путем добавления элементов одного за другим:

![Дерево Фенвика](https://habrastorage.org/webt/pv/8v/1o/pv8v1o_ftl9czbpx9v49fhpafwq.gif)

Интерактивную визуализацию ДИД можно посмотреть [здесь.](https://visualgo.net/en/fenwicktree)

Сложность

Временная

| Запрос суммы | Обновление |
| ------------ | ---------- |
| O(log(n))    | O(log(n))  |

Пространственная

O(n)

## 14. Граф

Описание

[Википедия](<https://ru.wikipedia.org/wiki/%D0%93%D1%80%D0%B0%D1%84_(%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)>)

[YouTube](https://www.youtube.com/watch?v=VehB3eglQMQ)

Граф (graph) — это абстрактный тип данных, реализующий математические концепции направленного и ненаправленного (ориентированного и неориентированного) графов (соответствующий раздел математики называется теорией графов).

Граф состоит из конечного (потенциально изменяющегося) набора узлов (вершин, точек) (nodes, vertices, points), а также набора ненаправленных или, соответственно, направленных пар этих узлов. Эти пары называются ребрами (арки, линии, стрелки — для направленного графа) (edges, arcs, lines, arrows). Узлы могут быть как частью графа, так и внешними сущностями, представленными целочисленными индексами или ссылками.

Для разных областей применения графы могут различаться направленностью, ограничениями на количество ребер и дополнительными данными о вершинах и ребрах. Многие структуры, представляющие практический интерес в математике и информатике, могут быть представлены в виде графов. Например, строение Википедии можно смоделировать при помощи ориентированного графа, в котором вершинами будут выступать статьи, а ребрами — гиперссылки.

![Граф](https://habrastorage.org/r/w1560/webt/f0/v2/gw/f0v2gwoaz-tbccnhtzc3qqyludw.png)

Примеры неориентированного и ориентированного графов

Обратите внимание: ребра графа часто имеют вес, который используется для определения "стоимости" пути.

[Любопытная визуализация графа.](https://poloclub.github.io/argo-graph-lite/)

Реализация

Начнем с реализации узла графа. Для представления ребер узла целесообразно использовать связный список (см. часть 1, раздел 1):
