# JavaScript: структуры данных и алгоритмы. Часть 5

## 15. Система непересекающихся множеств

Описание

[Википедия](https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D0%BD%D0%B5%D0%BF%D0%B5%D1%80%D0%B5%D1%81%D0%B5%D0%BA%D0%B0%D1%8E%D1%89%D0%B8%D1%85%D1%81%D1%8F_%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2)

[YouTube](https://www.youtube.com/watch?v=RAFQZa-8Wh4)

Система непересекающихся множеств (disjoint set) (также называемая структурой данных поиска объединения (пересечения) (union-find data structure) или множеством поиска слияния (merge-find set)) — это структура данных, которая содержит множество элементов, разделенных на определенное количество непересекающихся подмножеств. Она обеспечивает почти константное время выполнения операций (ограниченное обратной функцией Аккермана) добавления новых множеств, объединения существующих множеств и определения принадлежности элементов к одному множеству. Среди прочего, СНМ играет ключевую роль в алгоритме Краскала для построения минимального остовного дерева взвешенного связного неориентированного графа.

Основные операции СНМ:

- MakeSet(x) — создает одноэлементное множество {x}
- Find(x) — возвращает идентификатор множества (выделенный или репрезентативный элемент), содержащего элемент x
- Union(x, y) — объединяет множества, содержащие x и y

![Дерево отрезков](https://habrastorage.org/r/w1560/webt/sg/9y/kh/sg9ykhueonz1t3saw60flfwfrvm.png)

8 непересекающихся множеств, созданных с помощью MakeSet

![Дерево отрезков](https://habrastorage.org/r/w1560/webt/kb/sj/sx/kbsjsx6johtsg4dscm9copzr91e.png)

Группировка множеств с помощью Union

## 16. Фильтр Блума

Описание

[Википедия](https://ru.wikipedia.org/wiki/%D0%A4%D0%B8%D0%BB%D1%8C%D1%82%D1%80_%D0%91%D0%BB%D1%83%D0%BC%D0%B0)

[YouTube](https://www.youtube.com/watch?v=V3pzxngeLqw&t=26s)

Фильтр Блума (Bloom filter) — это пространственно-эффективная вероятностная структура данных, предназначенная для определения наличия элемента во множестве. С одной стороны, эта структура является очень быстрой и использует минимальный объем памяти, с другой стороны, возможны ложноположительные (false positive) результаты. Ложноотрицательные (false negative) результаты невозможны. Другими словами, фильтр возвращает либо "элемент МОЖЕТ содержаться во множестве", либо "элемент ТОЧНО НЕ содержится во множестве". Фильтр Блума может использовать любое количество памяти, но, как правило, чем больше памяти, тем ниже вероятность ложноположительных результатов.

Блум предложил эту технику для применения в областях, где количество исходных данных потребовало бы непрактично много памяти в случае применения условно безошибочных техник хеширования.

Описание алгоритма

Пустой фильтр Блума представлен массивом из m битов, установленных в 0. Должно быть определено k независимых хеш-функций, отображающих каждый элемент множества в одну из m позиций массива, генерируя единообразное случайное распределение. Обычно k задается константой, которая намного меньше m и пропорциональна количеству добавляемых элементов. Точный выбор k и постоянной пропорциональности m определяются уровнем ложных срабатываний фильтра.

Вот пример фильтра Блума, представляющего множество {x, y, z}. Цветные стрелки показывают позиции (индексы) битового массива, соответствующие элементам множества. Элемент w не содержится во множестве {x, y, z}, потому что он привязан к позиции массива, равной 0. В данном случае m = 18, а k = 3.

![Фильтр Блума](https://habrastorage.org/r/w1560/webt/mx/bt/_e/mxbt_eoh1fk17csnkjnyfpzxxqa.png)

Для добавления в фильтр элемента e необходимо записать 1 в каждую позицию h1(e), ..., hk(e) (хеш-функции) битового массива.

Для определения наличия элемента e во множестве необходимо проверить состояние битов h1(e), ..., hk(e). Если хотя бы один бит имеет значение 0, элемент отсутствует. Если все биты имеют значение 1, структура сообщает, что элемент присутствует. При этом, может возникнуть две ситуации: либо элемент действительно содержится во множестве, либо все биты оказались установлены случайно при добавлении других элементов. Второй случай является источником ложноположительных результатов.

Операции

Фильтр Блума позволяет выполнять две основные операции: вставка и поиск элемента. Поиск может завершаться ложноположительными результатами. Удаление элементов возможно, но проблематично.

Другими словами, в фильтр можно добавлять элементы, а на вопрос о наличии элемента структура отвечает либо "нет", либо "возможно".

Операции вставки и поиска выполняются за время O(1).

Создание фильтра

При создании фильтра указывается его размер. Размер нашего фильтра составляет 100. Все элементы устанавливаются в false (по сути, тоже самое, что 0).

В процессе добавления генерируется хеш элемента с помощью трех хеш-функций. Эти функции возвращают индексы. Значение по каждому индексу обновляется на true.

В процессе поиска также генерируется хеш элемента. Затем проверяется, что все значения по индексам являются true. Если это так, то элемент может содержаться во множестве.

Однако мы не можем быть в этом уверены на 100%, поскольку биты могли быть установлены при добавлении других элементов.

Если хотя бы одно значение равняется false, элемент точно отсутствует во множестве.

Ложноположительные результаты

Вероятность ложноположительных срабатываний определяется тремя факторами: размером фильтра (m), количеством используемых хеш-функций (k) и количеством элементов, добавляемых в фильтр (n).

Формула выглядит следующим образом:

( 1 — e -kn/m ) k

Значения этих переменных выбираются, исходя из приемлемости ложноположительных результатов.

Применение

Фильтр Блума может использоваться в блогах. Он идеально подходит для определения статей, которые пользователь еще не читал, за счет добавления в фильтр статей, прочитанных им.

Некоторые статьи будут отфильтрованы по ошибке, но цена приемлема: пользователь не увидит нескольких статей, зато ему будут показываться новые статьи при каждом посещении сайта.

Подробнее о фильтре Блума можно почитать в [этой статье.](https://habr.com/ru/companies/timeweb/articles/806383/)

## 17. Кэш актуальных данных

Описание

[Википедия](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B_%D0%BA%D1%8D%D1%88%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)

[YouTube](https://www.youtube.com/watch?v=5JjISpzM8uMs)

Кэш актуальных (часто используемых) данных (least recently used (LRU) cache) организует (хранит) элементы таким образом, что мы можем легко определить, какие элементы используются часто, а какие — редко.

Реализация КАД включает в себя:

- конструктор LRUCache(capacity: number), инициализирующий КАД определенного размера (capacity, положительное целое число)
- метод get(key: string), возвращающий значение по ключу (key) или null
- метод set(key: string, value: any), обновляющий или добавляющий значение (value) по ключу (key). При превышении capacity из кэша удаляется (вытесняется) самое старое (наименее используемое) значение

Функции get и set должны выполняться за константное время O(1).

### Сложность

Временная

| get  | set  |
| ---- | ---- |
| O(1) | O(1) |

Пространственная

O(n)

Реализация

Двусвязный список и хеш-таблица

В следующей реализации КАД мы будем использовать хеш-таблицу (см. часть 2, раздел 5) для константного (в среднем) доступа к элементам и двойной связный список (см. часть 1, раздел 2) для константного обновления и вытеснения элементов.

![КАД](https://habrastorage.org/r/w1560/webt/rl/ad/gt/rladgtulm15sg3xmoyxmudez5f0.jpeg)

Реализация, в которой используется связный список, полезна в целях обучения, поскольку позволяет понять, как достигается время выполнения O(1) операций get и set.

Однако КАД легче реализовать с помощью объекта Map, который хранит пары "ключ-значение" и запоминает порядок добавления ключей. Мы можем хранить последний используемый элемент в конце карты за счет его удаления и повторного добавления. Элемент, находящийся в начале карты, первым вытесняется из кэша. Для проверки порядка элементов можно использовать IteratorIterable, такой как map.keys()
