# JavaScript: структуры данных и алгоритмы. Часть 2

## 5. Хэш-таблица (Hash Table)

Описание

[Википедия](https://ru.wikipedia.org/wiki/%D0%A5%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0)

[YouTube](https://www.youtube.com/watch?v=cWbuK7C13HQ)

Хэш-таблица (hash table) — это структура данных, которая реализует абстрактный тип данных "ассоциативный массив" и позволяет хранить пары "ключ-значение". Хэш-таблица использует так называемую хэш-функцию (hash function), которая принимает ключ и возвращает индекс массива, по которому будет храниться значение (см. хорошее видео про хэширование). Пример хэш-таблицы, в которой ключом выступает имя человека, а значением адрес его электронной почты:

![Хэш-таблица](https://habrastorage.org/r/w1560/webt/rx/lo/u4/rxlou4t-at0bmzeeno2bll_2igs.png)

В идеале хэш-функция должна генерировать уникальный индекс для каждого ключа. Однако реальные хэш-таблицы используют несовершенные хэш-функции, генерирующие одинаковые индексы для разных ключей. Такие ситуации называются коллизиями (collisions). Существует несколько способов их решения, наиболее популярными из которых являются: хэш-таблица с цепочками и хэш-таблица с открытой адресацией.


Метод цепочек подразумевает хранение значений, соответствующих одному индексу в виде связного списка (linked list) (см. часть 1, раздел 1):

![Хэш-таблица](https://habrastorage.org/r/w1560/webt/et/dn/jw/etdnjwllpuzxjxnp4l5uwjvqk0i.png)

Метод открытой адресации помещает значение по совпадающему индексу в первую свободную ячейку:

![Хэш-таблица](https://habrastorage.org/r/w1560/webt/oi/io/li/oiiolihgcyn10bwjxkj4zhtqkcc.png)


## 6. Куча

Описание

[Википедия](https://ru.wikipedia.org/wiki/%D0%9A%D1%83%D1%87%D0%B0_(%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85))

[YouTube](https://www.youtube.com/watch?v=bO6h0NbbUEg)

Куча (heap) — это специализированная структура данных типа "дерево" (tree), которая удовлетворяет свойству кучи: если B является узлом-потомком узла A, то k(A) >= k(B), где k(X) — ключ (идентификатор) узла. Из этого следует, что элемент с наибольшим значением ключа всегда является корневым узлом (root node) кучи, поэтому такие кучи называют max-кучами (max heaps):

![Куча](https://habrastorage.org/r/w1560/webt/oj/f2/tw/ojf2tw7pyohegjkuug9tbqbwyre.png)

Приведенную max-кучу можно представить в виде массива следующим образом:

![Куча](https://habrastorage.org/r/w1560/webt/ra/er/en/raerencrfmantpcrfbgdc6iqmji.png)

Если дерево перевернуть, то корневым узлом всегда будет элемент с наименьшим значением. Такие кучи называют min-кучами:

![Куча](https://habrastorage.org/r/w1560/webt/ir/5v/rd/ir5vrdxssdly_uih82hq7slokr4.png)

Не существует никаких ограничений относительно того, сколько узлов-потомков имеет каждый узел кучи, хотя на практике их число обычно не более двух (такие кучи называют "двоичными" или "бинарными" (binary)). Куча является максимально эффективной реализацией абстрактного типа данных, который называется "очередью с приоритетом" (см. следующий раздел). Кучи имеют решающее значение в некоторых эффективных алгоритмах на графах, таких, как алгоритм Дейкстры на d-кучах и сортировка [методом пирамиды](https://ru.wikipedia.org/wiki/%D0%9F%D0%B8%D1%80%D0%B0%D0%BC%D0%B8%D0%B4%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0).

Интерактивную визуализации кучи можно посмотреть [здесь.](https://www.cs.usfca.edu/~galles/JavascriptVisual/Heap.html)


### Сложность

### Временная сложность кучи зависит от ее типа.

|Тип кучи        |	find-max|	delete-max|	insert | increase-key|	meld |
|--------------- |----------|-------------|--------|-------------|-------|
|Binary	         |Θ(1)	    |Θ(log n)     |O(log n)|	O(log n)|	Θ(n) |
|Leftist         |Θ(1)	    |Θ(log n)	  |Θ(log n)|	O(log n)|Θ(log n)|
|Binomial        |Θ(1)	    |Θ(log n)	  |Θ(1)	   |    O(log n)|O(log n)|
|Fibonacci       |	Θ(1)	|Θ(log n)	  |Θ(1)	   |        Θ(1)|	 Θ(1)|
|Pairing         |	Θ(1)	|Θ(log n)	  |Θ(1)	   |    o(log n)|	 Θ(1)|
|Brodal          |	Θ(1)	|Θ(log n)	  |Θ(1)	   |        Θ(1)|	Θ(1) |
|Rank-pairing	 |Θ(1)	    |Θ(log n)	  |Θ(1)	   |        Θ(1)|	Θ(1) |
|Strict Fibonacci|	Θ(1)	|Θ(log n)	  |Θ(1)    |        Θ(1)| 	Θ(1) |
|2-3 heap	     |O(log n)	|O(log n)	  |O(log n)|	    Θ(1)|	?    |

Где:


find-max (или find-min): поиск максимального значения в max-куче или минимального значения в min-куче, соответственно (похоже на peek в очереди или стеке)
- delete-max (or delete-min): удаление корневого узла
- insert: добавление в кучу нового значения (похоже на push в стеке или enqueue в очереди)
- increase-key или decrease-key: обновление значения узла
- meld: объединение 2 куч в 1 с уничтожением оригиналов

Реализация

В рамках этой статьи мы рассмотрим реализацию только бинарной кучи.
Начнем с реализации родительского (или супер, или абстрактного) класса для min- и max-куч.

## 7. Очередь с приоритетом

Описание

[Википедия](https://ru.wikipedia.org/wiki/%D0%9E%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C_%D1%81_%D0%BF%D1%80%D0%B8%D0%BE%D1%80%D0%B8%D1%82%D0%B5%D1%82%D0%BE%D0%BC_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5))

[YouTube](https://www.youtube.com/watch?v=y_2toG5-j_M)

Очередь с приоритетом (priority queue) — это абстрактный тип данных, похожий на обычную очередь (см. часть 1, раздел 3) или стек (см. часть 1, раздел 4), за исключением того, что в ней каждый элемент имеет определенный "приоритет" (priority). Элемент с более высоким приоритетом обрабатывается перед элементом с более низким приоритетом. Если два элемента имеют одинаковый приоритет, они обрабатываются в порядке их расположения в очереди.


Несмотря на то, что очереди с приоритетом часто реализуются с помощью куч, они концептуально различаются. Очередь с приоритетом — это абстрактная концепция, вроде "списка" (list) или "карты" (map). Как список может быть реализован с помощью связного списка (см. часть 1, раздел 1) или массива, так и очередь с приоритетом может быть реализована с помощью кучи или другим способом, например, с помощью неупорядоченного массива.


Интерактивную визуализации очереди с приоритетом можно посмотреть [здесь.](https://priority-queue-visualizer.vercel.app/)

### Сложность

Временная сложность очереди с приоритетом составляет O(n) или O(n*log(n)) (зависит от реализации).

Реализация

Для реализации очереди с приоритетом мы воспользуемся min-кучей


## 8. Префиксное дерево

[Википедия](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D1%84%D0%B8%D0%BA%D1%81%D0%BD%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE)

[YouTube](https://www.youtube.com/watch?v=fqfkeJ09G0c)

Префиксное дерево (или бор, или луч, или нагруженное дерево) (trie) — структура данных, позволяющая хранить ассоциативный массив (или другое динамическое множество), ключами которого чаще всего являются строки. Представляет собой корневое дерево, каждое ребро которого помечено каким-то символом так, что для любого узла все ребра, соединяющие этот узел с его потомками, помечены разными символами. Некоторые узлы префиксного дерева выделены и считается, что префиксное дерево содержит данную строку-ключ тогда и только тогда, когда эту строку можно прочитать на пути из корня до некоторого (единственного для этой строки) выделенного узла.


Таким образом, в отличие от бинарных деревьев поиска (binary search tree), ключ, идентифицирующий конкретный узел дерева, не явно хранится в данном узле, а задается положением данного узла в дереве. Получить ключ можно выписыванием символов, помечающих ребра на пути от корня до узла. Ключ корневого узла — пустая строка. Часто в выделенных узлах хранят дополнительную информацию, связанную с ключом, и обычно выделенными являются только листья, а иногда и некоторые внутренние узлы.

![дерево](https://habrastorage.org/r/w1560/webt/tk/yc/-w/tkyc-wz6y5jcnie6zzpjpsk3_oi.png)

### Сложность


Временная сложность префиксного дерева составляет O(n) (при использовании хэш-таблицы).


Реализация


Для реализации префиксного дерева мы будем использовать хэш-таблицу