# JavaScript: структуры данных и алгоритмы. Часть 2

## 1. 5. Хэш-таблица (Hash Table)

Описание

[Википедия](https://ru.wikipedia.org/wiki/%D0%A5%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0)

[YouTube](https://www.youtube.com/watch?v=cWbuK7C13HQ)

Хэш-таблица (hash table) — это структура данных, которая реализует абстрактный тип данных "ассоциативный массив" и позволяет хранить пары "ключ-значение". Хэш-таблица использует так называемую хэш-функцию (hash function), которая принимает ключ и возвращает индекс массива, по которому будет храниться значение (см. хорошее видео про хэширование). Пример хэш-таблицы, в которой ключом выступает имя человека, а значением адрес его электронной почты:

![Хэш-таблица](https://habrastorage.org/r/w1560/webt/rx/lo/u4/rxlou4t-at0bmzeeno2bll_2igs.png)

В идеале хэш-функция должна генерировать уникальный индекс для каждого ключа. Однако реальные хэш-таблицы используют несовершенные хэш-функции, генерирующие одинаковые индексы для разных ключей. Такие ситуации называются коллизиями (collisions). Существует несколько способов их решения, наиболее популярными из которых являются: хэш-таблица с цепочками и хэш-таблица с открытой адресацией.


Метод цепочек подразумевает хранение значений, соответствующих одному индексу в виде связного списка (linked list) (см. часть 1, раздел 1):

![Хэш-таблица](https://habrastorage.org/r/w1560/webt/et/dn/jw/etdnjwllpuzxjxnp4l5uwjvqk0i.png)

Метод открытой адресации помещает значение по совпадающему индексу в первую свободную ячейку:

![Хэш-таблица](https://habrastorage.org/r/w1560/webt/oi/io/li/oiiolihgcyn10bwjxkj4zhtqkcc.png)


## 6. Куча

Описание

[Википедия](https://ru.wikipedia.org/wiki/%D0%9A%D1%83%D1%87%D0%B0_(%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85))

[YouTube](https://www.youtube.com/watch?v=bO6h0NbbUEg)

Куча (heap) — это специализированная структура данных типа "дерево" (tree), которая удовлетворяет свойству кучи: если B является узлом-потомком узла A, то k(A) >= k(B), где k(X) — ключ (идентификатор) узла. Из этого следует, что элемент с наибольшим значением ключа всегда является корневым узлом (root node) кучи, поэтому такие кучи называют max-кучами (max heaps):

![Куча](https://habrastorage.org/r/w1560/webt/oj/f2/tw/ojf2tw7pyohegjkuug9tbqbwyre.png)

Приведенную max-кучу можно представить в виде массива следующим образом:

![Куча](https://habrastorage.org/r/w1560/webt/ra/er/en/raerencrfmantpcrfbgdc6iqmji.png)

Если дерево перевернуть, то корневым узлом всегда будет элемент с наименьшим значением. Такие кучи называют min-кучами:

![Куча](https://habrastorage.org/r/w1560/webt/ir/5v/rd/ir5vrdxssdly_uih82hq7slokr4.png)

Не существует никаких ограничений относительно того, сколько узлов-потомков имеет каждый узел кучи, хотя на практике их число обычно не более двух (такие кучи называют "двоичными" или "бинарными" (binary)). Куча является максимально эффективной реализацией абстрактного типа данных, который называется "очередью с приоритетом" (см. следующий раздел). Кучи имеют решающее значение в некоторых эффективных алгоритмах на графах, таких, как алгоритм Дейкстры на d-кучах и сортировка [методом пирамиды](https://ru.wikipedia.org/wiki/%D0%9F%D0%B8%D1%80%D0%B0%D0%BC%D0%B8%D0%B4%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0).

Интерактивную визуализации кучи можно посмотреть [здесь.](https://www.cs.usfca.edu/~galles/JavascriptVisual/Heap.html)


## Сложность

### Временная сложность кучи зависит от ее типа.

|Тип кучи        |	find-max|	delete-max|	insert | increase-key|	meld |
|--------------- |----------|-------------|--------|-------------|-------|
|Binary	         |Θ(1)	    |Θ(log n)     |O(log n)|	O(log n)|	Θ(n) |
|Leftist         |Θ(1)	    |Θ(log n)	  |Θ(log n)|	O(log n)|Θ(log n)|
|Binomial        |Θ(1)	    |Θ(log n)	  |Θ(1)	   |    O(log n)|O(log n)|
|Fibonacci       |	Θ(1)	|Θ(log n)	  |Θ(1)	   |        Θ(1)|	 Θ(1)|
|Pairing         |	Θ(1)	|Θ(log n)	  |Θ(1)	   |    o(log n)|	 Θ(1)|
|Brodal          |	Θ(1)	|Θ(log n)	  |Θ(1)	   |        Θ(1)|	Θ(1) |
|Rank-pairing	 |Θ(1)	    |Θ(log n)	  |Θ(1)	   |        Θ(1)|	Θ(1) |
|Strict Fibonacci|	Θ(1)	|Θ(log n)	  |Θ(1)    |        Θ(1)| 	Θ(1) |
|2-3 heap	     |O(log n)	|O(log n)	  |O(log n)|	    Θ(1)|	?    |

Где:


find-max (или find-min): поиск максимального значения в max-куче или минимального значения в min-куче, соответственно (похоже на peek в очереди или стеке)
- delete-max (or delete-min): удаление корневого узла
- insert: добавление в кучу нового значения (похоже на push в стеке или enqueue в очереди)
- increase-key или decrease-key: обновление значения узла
- meld: объединение 2 куч в 1 с уничтожением оригиналов

Реализация

В рамках этой статьи мы рассмотрим реализацию только бинарной кучи.
Начнем с реализации родительского (или супер, или абстрактного) класса для min- и max-куч.